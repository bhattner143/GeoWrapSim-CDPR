% Class for performing experiments with BMWrapArm
%
% Author        : Dipankar Bhattacharya
% Created       : 2022
% Description    :
%    This class enables experiments on systems actuated by myomuscles.
%    Current implementation only focuses on operational space trajectories.

classdef BMWrapArmMyoExperiment < ExperimentBase    
    properties (SetAccess = private)  
        controller;          % Suppose to be an operational space controller
        control_mode;       % Enum of MyoControlModeType
%         fk_solver;           % Forward kinematics solver
        
        results;             % Struct holding exp results
        stopping_t;          % Stopping time of the trajectory
        performance;         % Performancer function
        
        t;                   % Loop index
        ndi_interface;       % Interface for using external sensor
        
        l_cmd;               % Cable length commands generated by the FD or IK models. 
        lcmd_offset;         % Offset for length command to prevent slack
        length_fb;           % IK length output + random noise mimicking the realtime length sensor reading
        length_fb_array;     % Storing the time evolution of length_fb (required for FK-->evalForKinematicsFromCableCommands)
        
        q_init;              % Initial q
        q_sol;               % Joint position solution obtained from FK in MATLAB
        q_dot_sol;           % Joint velocity solution obtained from FK in MATLAB
        
        y_ref;               % Storing the current reference operational space trajectory position
        y_dot_ref;           % Storing the current reference operational space trajectory velocity
        y_ddot_ref;          % Storing the current reference operational space trajectory acceleration
        y_ref_array;         % Storing the time evolution of reference operational space trajectory position
        y_dot_ref_array;     % Storing the time evolution of reference operational space trajectory velocity
        
        q_ref;               % Storing the current reference joint space trajectory position
        q_dot_ref;           % Storing the current reference joint space trajectory velocity         
        q_ddot_ref;          % Storing the current reference joint space trajectory acceleration  
        
        % Only applicable for BMArm robot i.e. hardware_flag = 1
        q_fk_roscpp;         % Storing the current FK joint space trajectory position calculated by the roscpp
        q_fk_dot_roscpp;     % Storing the current FK joint space trajectory velocity calculated by the roscpp
        q_fk_ddot_roscpp;    % Storing the current FK joint space trajectory acceleration calculated by the roscpp
        
        q_fk_sol_array;      % Storing the FK solved joint space position trajectory for the present reference trajectory
        q_fk_dot_sol_array;  % Storing the FK solved joint space velocity trajectory for the present reference trajectory
        
        results_struct;      % A structure storing all the relevant result arrays
        
        hardware_flag;       % Flag to determine control of real plant or plant model
        filter_flag;         % Flag to filter the length feedback
        
        fig_array;           % Array saving figures
        
        filter_param_struct; % Structure saving all th important filter parameters
        num_samples;
        wn;
        filter_coeff;
        
    end
    
    properties (Constant)
        %Set noise scaling factor for adding random noise to the length
        %output from the FK
        noise_scaling_factor = 0.00002;
        
        lineStyle = {'-','--',':','-.'};
        lineColor = {'r', [0.5,0,0.5],'b','k',[0,0.5,0.5],[0.5,0.5,0]};
    end
    
    methods
        % Constructor
        function obj = BMWrapArmMyoExperiment(interface, model, controller, control_mode, hardware_flag, filter_flag)
            % Create the hardware interface          
            obj@ExperimentBase(interface, model);
            obj.controller = controller;
%             obj.fk_solver = fk_solver;
            
            obj.hardware_flag = hardware_flag;
            
            if nargin < 7
                obj.filter_flag = false;
            else
                obj.filter_flag = filter_flag;
            end
                    
            if nargin > 3
                obj.control_mode = control_mode;
            else
                % Default: length mode
                obj.control_mode = MyoControlModeType.LENGTH;
            end
            obj.q_init = obj.model.q;
            obj.ndi_interface = [];
            
            if obj.hardware_flag
%                 obj.lcmd_offset = [1e-3;1e-3;1e-3;1e-3;1.0e-3;0.75e-3];%sph-->0.85-0.95e-3,toroidal-->0.65e-3
%                   obj.lcmd_offset = [0e-2;0e-3;0e-2;0e-3;1.0e-3;0.75e-3]
%                   obj.lcmd_offset = [0.0162    0.0035    0.0163    0.0036   -0.2020   -0.2017]';
%                   obj.lcmd_offset = [0.0362+0.0269    0.0035    0.0363+0.0269    0.0036   -0.2020   -0.2017]';
%                 obj.lcmd_offset = [0.0628    0.0034    0.0628    0.0046   -0.2010   -0.2000]'; %Cone cylinder 
%             obj.lcmd_offset = [-0.0014,0.0114,0.0686,0.2752,   -0.0   -0.0]'; %Almond
%             obj.lcmd_offset = [0.0686,-0.0014,0.2752,0.0114,   -0.0   -0.0]';
            obj.lcmd_offset = [0, 0.0034, 0, 0.0046, 0, 0]';
            else
                obj.lcmd_offset = zeros(6,1);               
            end
%             obj.lcmd_offset = [0;0;0;0;0;0];
%             obj.lcmd_offset = 0;
            
            
            if obj.hardware_flag
                % Open the hardware interface
                obj.openHardwareInterface();
            else
                obj.length_fb=zeros(obj.model.numCables,1);
            end
        end
        
        %% Initialise result holding arrays
        function initResults(obj, trajectory)         
            % Kinematics
            obj.results.q_soln = cell(length(trajectory.timeVector), 1);
            obj.results.q_d_soln = cell(length(trajectory.timeVector), 1);
            obj.results.q_dd_soln = cell(length(trajectory.timeVector), 1);
            obj.results.y_soln = cell(length(trajectory.timeVector), 1);            
            % Commands            
            obj.results.lcmd_soln = cell(length(trajectory.timeVector), 1);
            obj.results.fcmd_soln = cell(length(trajectory.timeVector), 1);
            % Feedbacks
            obj.results.l_soln = cell(length(trajectory.timeVector), 1);
            obj.results.f_soln = cell(length(trajectory.timeVector), 1); 
            obj.results.freq_soln = cell(length(trajectory.timeVector), 1); 

            % Initializing length feedback array to store the noisy IK output
            obj.length_fb_array = zeros(length(trajectory.timeVector), obj.model.numCables);

            obj.results_struct = struct(...
            't',                    zeros(length(trajectory.timeVector), 1),...
            't_iteration',          zeros(length(trajectory.timeVector), 1),...
            't_controller',         zeros(length(trajectory.timeVector), 1),...
            'freq',                 zeros(length(trajectory.timeVector), 1),...
            'y_ref',                zeros(length(trajectory.timeVector), obj.model.numOperationalDofs),...
            'y_dot_ref',            zeros(length(trajectory.timeVector), obj.model.numOperationalDofs),...
            'y_ddot_ref',           zeros(length(trajectory.timeVector), obj.model.numOperationalDofs),...
            'y_actual',             zeros(length(trajectory.timeVector), obj.model.numOperationalDofs),...
            'q_ref',                zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'q_dot_ref',            zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'q_ddot_ref',           zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'q_fk',                 zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'q_fk_dot',             zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'q_fk_ddot',            zeros(length(trajectory.timeVector), obj.model.numDofs),...
            'f_cmd',                zeros(length(trajectory.timeVector), obj.model.numCables),...
            'l_cmd',                zeros(length(trajectory.timeVector), obj.model.numCables),...
            'l_fb',                 zeros(length(trajectory.timeVector), obj.model.numCables),...
             'L',                   struct                                   );

            % Initializing q_d and q_dot solution array to store the FK
            % obtained from noisy IK length ouput
            obj.q_fk_sol_array = zeros(length(trajectory.timeVector), obj.model.numDofs);
            obj.q_fk_dot_sol_array = zeros(length(trajectory.timeVector), obj.model.numDofs);

            % Initializing q_d and q_dot solution array to store the FK
            % obtained from noisy IK length ouput
            obj.y_ref_array = zeros(length(trajectory.timeVector), obj.model.numOperationalDofs);
            obj.y_dot_ref_array = zeros(length(trajectory.timeVector), obj.model.numOperationalDofs);
        end
        %% Inverse Kinematics
        % Evaluate inverse kinematics and send cable commands
        function evalInvKinematicsAndSendLenghCommands(obj,q_ref,...
                q_d_ref, q_dd_ref, lcmd_offset, w_ext)

            % This function evaluates the inverse kinematics of the
            % cable-driven robot from a reference joint position. The
            % determined cable lengths and joint position and velocity for
            % each joint trajectory are then send to the robot to follow
            % the joint space trajectory

            if nargin < 5
                lcmd_offset = zeros(obj.model.numCables, 1);
                w_ext = zeros(obj.model.numDofs, 1);            
            elseif nargin < 6
                w_ext = zeros(obj.model.numDofs, 1);
            end

            %Evaluate inverse kinematics i.e. corresponding cable lengths
            obj.model.update(q_ref, q_d_ref, q_dd_ref,...
                w_ext);
            
            %temporarily setting length for 0,0,0
%             l_temp = [0.255574138999590, 0.272567674886028, 0.255574124752037, 0.272567673264351, 0.47339 , 0.47339]';
%               a = 0.01;
%               l_temp = [0.001,0+a,0.001,0+a, 0.47339 , 0.47339]';
%             l_temp = [0.248882696475744, 0.285312051578654, 0.248882691514784, 0.285312049929566, 0.47339 , 0.47339]';
%             l_temp = [0.241809599695931	0.297740564274744	0.241809592123773	0.297740562596958,  0.47339 , 0.47339]';
            if obj.hardware_flag
                % Send cable commands
                obj.hardwareInterface.sendCableCommands(obj.l_cmd-lcmd_offset,...
                    q_ref, q_d_ref);
%                   obj.hardwareInterface.sendCableCommands(l_temp,...
%                     q_ref, q_d_ref);
            end
        end
        %%
        %This method creates a linear trajectory between two
        % specified points in the joint-space with given time and time-
        % step
        function joint_trajectory = fromTwoPtsCreateJointTraj(obj, q_ref_traj, time_span, dt)
            % This function creates a linear trajectory between two
            % specified points in the joint-space with given time and time-
            % step

            % Generate traj
            joint_trajectory = JointTrajectory.LinearTrajectoryCreate(q_ref_traj, ...
                [0 time_span], dt, obj.model.bodyModel);
        end
        %% Send robot to inittial joint position
        % Send the robot from zero joint position to a specified joint
        % position by creating a linear trajectory between the two points.
        function sendRobotToInitJointPosition(obj, trajectory, filter_l_fb)
        % This function commands the robot to go to the initial joint
        % position by following the trajectory object passed as an
        % input argument. The trajectory object contains all the
        % necessary information about the trajectory

            if nargin < 3
                filter_l_fb = false;
                %Filter not implemented
            end

            for t = 1:length(trajectory.timeVector)
                % Mark starting time
                freq_tic = tic;
                dt = trajectory.timeStep;

                % Joint space reference
                q_ref = trajectory.q{t};
                q_d_ref = trajectory.q_dot{t};
                q_dd_ref = trajectory.q_ddot{t};
                lcmd_offset = obj.lcmd_offset;

                obj.evalInvKinematicsAndSendLenghCommands(q_ref, q_d_ref, ...
                    q_dd_ref, lcmd_offset);

                % Evaluate FK i.e. q, q_dot if solving for simulation else
                % read from the hardware, when hardware flag is set ot 1
                if obj.hardware_flag

                    % Acquiring the length feedback from the BMArm length
                    % sensor
                    [obj.length_fb, obj.q_fk_dot_roscpp , obj.q_fk_dot_roscpp ] = ...
                        obj.hardwareInterface.poseFeedbackRead();

                    obj.q_sol = obj.q_fk_dot_roscpp;
                    obj.q_dot_sol = obj.q_fk_dot_roscpp;

                    obj.q_fk_sol_array(t,:) = obj.q_sol;
                    obj.q_fk_dot_sol_array(t,:) = obj.q_dot_sol;

                    % Store robot's length feedback from the sensor.
                    obj.length_fb_array(t,:) = obj.length_fb;
                else
                    % Setting length feedback same as that of the IK output and
                    % adding random noise to it to mimic the sensor output
                    obj.length_fb = obj.model.cableModel.lengths-lcmd_offset + obj.noise_scaling_factor*randn(obj.model.numCables,1);
                    % Store noisy length output of the simulated robot's FK 
                    obj.length_fb_array(t,:) = obj.length_fb;

                    % Evaluate FK
                    obj.evalForKinematicsFromCableCommands(obj.length_fb_array, ...
                        trajectory.q{1}, trajectory.q_dot{1}, t, ...
                        trajectory.timeStep)

                    % This q and q_dot is coming from the simulated robot's IK
                    obj.q_fk_sol_array(t,:) = obj.q_sol;
                    obj.q_fk_dot_sol_array(t,:) = obj.q_dot_sol;
                end

                if obj.filter_flag

                end

                % Maintain control frequency
                elapsed = toc(freq_tic);
                while elapsed < dt
                    elapsed = toc(freq_tic);
                end
            end
        end
        %%         
        % Run open-loop control on an operational space traj using the defined control mode
        function l_fb = runJointSpaceInitialization(obj, time_step, isReturn, isArrayInitialized, l_cmd)            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % 0. Setup
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            pause(1);
            obj.l_cmd = l_cmd;
            % Check whether returning to init pose
            if nargin < 2
                time_step = 0.033;
                isReturn = false;
                isArrayInitialized = 0;
            elseif nargin < 3
                isReturn = false;
                isArrayInitialized = 0;
            elseif nargin < 4
                isArrayInitialized = 0;
            end

            % Define frequency
            dt = time_step;
            % Publish control mode

            if obj.hardware_flag
                rosparam('set','/control_mode', 'LENGTH');  
            end

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % 1. Move to a specified joint position from zero position by
            % follwoing the trajectory created by
            % 'fromTwoPtsCreateJointTraj'
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            % Initialize zero pose to hardware to init FK
            % Setting the robot to move to joint space value of zero

            q_ref = zeros(obj.model.numDofs, 1); 
            q_d_ref = zeros(obj.model.numDofs, 1); 
            q_dd_ref = zeros(obj.model.numDofs, 1);
            % Evaluate inverse kinematics and send cable length commands
            % for zero joint space position
            obj.evalInvKinematicsAndSendLenghCommands(q_ref, q_d_ref, q_dd_ref, obj.lcmd_offset);
            pause(1);
            [l_fb, q_fk,q_dot_fk] = obj.hardwareInterface.poseFeedbackRead();

            if obj.hardware_flag ~= 1
                % Setting length feedback same as that of the IK output and
                % adding random noise to it to mimic the sensor output
                obj.length_fb = obj.model.cableModel.lengths-obj.lcmd_offset + obj.noise_scaling_factor*randn(obj.model.numCables,1);
            end

%             % Get init joint position            
%             q_ref_traj = cell(2,1);
%             q_ref_traj{1} = {zeros(3,1); 0};
%             q_ref_traj{2} = {obj.q_init(1:3); obj.q_init(4)};
%             time_span = 4;
% 
%             % Generate init traj from the init joint position
%             init_trajectory = obj.fromTwoPtsCreateJointTraj(q_ref_traj,time_span, dt);
%         %             init_trajectory = JointTrajectory.LinearTrajectoryCreate(q_ref_traj, [0 time_span], dt, obj.model.bodyModel);
% 
%             if isArrayInitialized ~= 1
%                 % Init result arrays
%                 obj.initResults(init_trajectory);
%             end
% 
%             % From zero position, send the robot to the initial joint
%             % position, which is the final pt of the init_trajectory
%             obj.sendRobotToInitJointPosition(init_trajectory);     
        %             
            if obj.hardware_flag
                % Publish control mode
                if (obj.control_mode==MyoControlModeType.LENGTH)
                    rosparam('set','/control_mode', 'LENGTH');
                elseif (obj.control_mode==MyoControlModeType.FORCE)
                    rosparam('set','/control_mode', 'FORCE');
                else
                    rosparam('set','/control_mode', 'ACCEL');
                end
            end

            % Take a rest...
            pause(1);
        end
    end %methods
end